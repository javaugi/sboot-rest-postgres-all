/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/Classes/Class.java to edit this template
 */
package com.spring5.repository;

import com.spring5.entity.Nurse;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;

/**
 *
 * @author javaugi
 */
@Repository
@Transactional
public interface  NurseRepository extends JpaRepository<Nurse, Long> {

}

/* 
Step 1: Identify the Performance Issue
Symptoms
1. Query takes 5+ seconds to return 100 records
2. Database CPU spikes during execution
3. Logs show thousands of individual queries

Performance Root cause
1. N+1 Query Problem: The eager fetching causes one query for patients and N additional queries for appointments
2. No Pagination: Loading all records at once
3. Missing Indexes: No indexes on frequently queried columns

Step 2: Optimization Solutions

Solutions
1. @OneToMany(mappedBy = "patient", fetch = FetchType.EAGER)
    private List<Appointment> appointments;
2. 
Solution 1: Fix N+1 with JOIN FETCH
@Query("SELECT p FROM Patient p JOIN FETCH p.appointments WHERE p.name LIKE %:name%")
List<Patient> findByNameWithAppointments(@Param("name") String name);
3. 
Solution 2: Add Pagination
@Query("SELECT p FROM Patient p JOIN FETCH p.appointments WHERE p.name LIKE %:name%")
Page<Patient> findByNameWithAppointments(@Param("name") String name, Pageable pageable);
4.
Solution 3: Add Database Indexes
@Entity
@Table(indexes = @Index(name = "idx_patient_name", columnList = "name"))
public class Patient {
    // ...
}
5.
Solution 4: Use DTO Projection Instead of Entities
public interface PatientWithAppointmentCount {
    Long getId();
    String getName();
    Long getAppointmentCount();
}

@Query("SELECT p.id as id, p.name as name, COUNT(a) as appointmentCount " +
       "FROM Patient p LEFT JOIN p.appointments a " +
       "WHERE p.name LIKE %:name% " +
       "GROUP BY p.id")
Page<PatientWithAppointmentCount> findPatientsWithAppointmentCount(@Param("name") String name, Pageable pageable);

6.
Solution 5: Batch Fetching
properties
# application.properties
spring.jpa.properties.hibernate.default_batch_fetch_size=20

6. Step 4: Additional Advanced Optimizations

Step 3: Verify Improvements
Before Optimization
1 query to get patients + 50 additional queries for appointments
2. Execution time: 5200ms
3. Memory usage: High (all data loaded)

After Optimization
1 query with JOIN FETCH + pagination
2. Execution time: 120ms
3. Memory usage: Controlled (only page of data loaded)


Step 4: Additional Advanced Optimizations
1. Second-Level Caching
@Entity
@Cacheable
@org.hibernate.annotations.Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
public class Patient {
    // ...
}
2. Read-Only Transactions for Queries
@Transactional(readOnly = true)
public Page<Patient> searchPatients(String name, Pageable pageable) {
    return patientRepository.findByNameWithAppointments(name, pageable);
}
3. Database-Specific Optimizations
@Query(value = "SELECT p.* FROM patients p " +
       "WHERE p.name LIKE %:name% " +
       "ORDER BY p.name " +
       "LIMIT :limit OFFSET :offset", 
       nativeQuery = true)
List<Patient> findByNameNative(@Param("name") String name, 
                             @Param("limit") int limit,
                             @Param("offset") int offset);

Interview Discussion Points
1. When explaining this optimization in an interview:
2. Start with the problem: "We noticed our patient search was slow because..."
3. Explain your diagnostic process: "I checked the logs and saw the N+1 query pattern..."
4. Detail your solutions: "First I implemented JOIN FETCH to reduce queries, then..."
5. Quantify improvements: "This reduced query time from 5s to 120ms and cut memory usage by..."
6. Mention alternatives considered: "I also evaluated batch fetching but chose JOIN FETCH because..."

Key Takeaways
1. Always monitor actual SQL queries generated by JPA
2. N+1 problems are common and solvable with JOIN FETCH
3. Pagination is essential for large datasets
4. Database indexes are often overlooked
5. Projections can significantly reduce memory usage

*/